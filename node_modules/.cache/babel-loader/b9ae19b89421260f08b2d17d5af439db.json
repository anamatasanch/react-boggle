{"ast":null,"code":"/* Ana Luisa Mata Sanchez\n   Software Development Studio\n   Assignment #2 - Test Plan for Boggle Solver\n*/\n//Trie node\nclass TrieNode {\n  constructor() {\n    this.children = new Object();\n    this.isEndOfWord = false;\n  }\n\n} //Function for inserting a word into the trie\n\n\nfunction insert(root, word) {\n  let currNode = root;\n\n  if (word.length < 16) {\n    for (let i = 0; i < word.length; i++) {\n      let letter = word.charAt(i); //If the letter is not in the children\n\n      if (!currNode.children.hasOwnProperty(letter.toUpperCase())) {\n        let nextNode = new TrieNode(); //Add the letter\n\n        currNode.children[letter.toUpperCase()] = nextNode; //Move to next node\n\n        currNode = nextNode;\n      } else {\n        //If letter is in the children, move to next node\n        currNode = currNode.children[letter.toUpperCase()];\n      }\n    }\n\n    currNode.isEndOfWord = true;\n  }\n} //FFind a word in the dictonary\n\n\nfunction find(root, word) {\n  let currNode = root;\n\n  for (let i = 0; i < word.length; i++) {\n    //If the letter is not in the children\n    let letter = word.charAt(i);\n\n    if (!currNode.children.hasOwnProperty(letter.toUpperCase())) {\n      //word is not in trie\n      return false;\n    } else {\n      //If letter is in the children, move to next node\n      if (currNode.children[letter.toUpperCase()]) {\n        currNode = currNode.children[letter.toUpperCase()];\n      }\n    }\n  } //All letters are in the trie, therefore the word is in the trie\n\n\n  return currNode.isEndOfWord;\n} //This function traverses all possible paths for a node\n\n\nfunction findWords(row, col, grid, dictionary, visited, word, root, words) {\n  //Mark the node as visited\n  visited[row][col] = '1'; //Add the letter in the node to the word\n\n  word = word + grid[row][col]; //Look for the word in the dictionary\n\n  if (word.length > 2 && find(root, word)) {\n    words.add(word);\n  } //Travel through all possible 8 nodes\n\n\n  for (let r = row - 1; r < row + 2; r++) {\n    for (let c = col - 1; c < col + 2; c++) {\n      //Check that it can travel to that node and it hasn't been visited yet\n      if (r >= 0 && r < grid.length && c >= 0 && c < grid[0].length && visited[r][c] !== '1') {\n        //Go to said node\n        findWords(r, c, grid, dictionary, visited, word, root, words);\n      }\n    }\n  } //Remove letter from the node and mark as unvisited to be able to do all combinations (travel to this node again from another node)\n\n\n  word = word - word.charAt(word.length - 1);\n  visited[row][col] = '0';\n} //This funtion solves the boggle\n\n\nfunction solver(grid, dictionary) {\n  //Check to see if dictionary and grid are not undefined\n  if (dictionary && grid) {\n    let root = new TrieNode();\n    let visited = new Array(grid.length);\n\n    for (let i = 0; i < dictionary.length; i++) {\n      if (dictionary[i]) {\n        insert(root, dictionary[i]);\n      }\n    } //Create the grid for the visited\n\n\n    for (let row = 0; row < grid.length; row++) {\n      visited[row] = new Array(grid[0].length);\n\n      for (let col = 0; col < grid[0].length; col++) {\n        visited[row].push('0');\n      }\n    }\n\n    let word = '';\n    let words = new Set(); //Go to every node in the grid\n\n    for (let row = 0; row < grid.length; row++) {\n      for (let col = 0; col < grid[0].length; col++) {\n        //Solve for this node as a root\n        findWords(row, col, grid, dictionary, visited, word, root, words);\n      }\n    }\n\n    return Array.from(words).sort();\n  } else {\n    return [];\n  }\n} //exports.findAllSolutions = solver;\n\n\nexport default solver;","map":{"version":3,"sources":["/Users/anamata/Documents/GitHub/react-boggle/src/boggle.js"],"names":["TrieNode","constructor","children","Object","isEndOfWord","insert","root","word","currNode","length","i","letter","charAt","hasOwnProperty","toUpperCase","nextNode","find","findWords","row","col","grid","dictionary","visited","words","add","r","c","solver","Array","push","Set","from","sort"],"mappings":"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","sourcesContent":["/* Ana Luisa Mata Sanchez\n   Software Development Studio\n   Assignment #2 - Test Plan for Boggle Solver\n*/\n\n//Trie node\nclass TrieNode{\n     constructor(){\n       this.children = new Object();\n       this.isEndOfWord = false;\n     }\n}\n\n//Function for inserting a word into the trie\nfunction insert(root,word){\n  let currNode = root;\n\n  if(word.length<16){\n    for(let i=0; i<word.length; i++){\n        let letter = word.charAt(i);\n\n        //If the letter is not in the children\n        if(!currNode.children.hasOwnProperty(letter.toUpperCase())){\n          let nextNode = new TrieNode();\n          //Add the letter\n          currNode.children[letter.toUpperCase()] = nextNode;\n          //Move to next node\n          currNode = nextNode;\n        }else{\n          //If letter is in the children, move to next node\n          currNode = currNode.children[letter.toUpperCase()];\n        }\n     }\n     currNode.isEndOfWord = true;\n   }\n}\n\n//FFind a word in the dictonary\nfunction find(root, word){\n  let currNode = root;\n\n  for(let i=0; i<word.length; i++){\n      //If the letter is not in the children\n      let letter = word.charAt(i);\n      if(!currNode.children.hasOwnProperty(letter.toUpperCase())){\n        //word is not in trie\n        return false;\n      }else{\n        //If letter is in the children, move to next node\n        if(currNode.children[letter.toUpperCase()]){\n          currNode = currNode.children[letter.toUpperCase()];\n        }\n      }\n  }\n\n  //All letters are in the trie, therefore the word is in the trie\n  return currNode.isEndOfWord;\n\n}\n\n//This function traverses all possible paths for a node\nfunction findWords(row, col, grid, dictionary, visited, word, root, words){\n  //Mark the node as visited\n  visited[row][col] = '1';\n  //Add the letter in the node to the word\n  word = word + grid[row][col];\n\n  //Look for the word in the dictionary\n  if(word.length>2 && find(root, word)){\n    words.add(word);\n  }\n\n  //Travel through all possible 8 nodes\n  for(let r = row-1;r<row+2;r++){\n    for(let c = col-1;c<col+2;c++){\n      //Check that it can travel to that node and it hasn't been visited yet\n      if((r>=0 && r<grid.length)&&(c>=0 && c<grid[0].length) && visited[r][c] !== '1'){\n        //Go to said node\n        findWords(r,c,grid,dictionary,visited,word,root,words);\n      }\n    }\n  }\n\n  //Remove letter from the node and mark as unvisited to be able to do all combinations (travel to this node again from another node)\n  word = word - word.charAt(word.length-1);\n  visited[row][col] = '0';\n}\n\n//This funtion solves the boggle\nfunction solver(grid, dictionary){\n  //Check to see if dictionary and grid are not undefined\n  if(dictionary && grid){\n    let root = new TrieNode();\n    let visited = new Array(grid.length);\n\n    for(let i = 0; i<dictionary.length; i++){\n      if(dictionary[i]){\n        insert(root, dictionary[i]);\n      }\n    }\n\n    //Create the grid for the visited\n    for(let row = 0; row < grid.length; row++){\n      visited[row] = new Array(grid[0].length)\n      for (let col = 0; col < grid[0].length; col++){\n        visited[row].push('0');\n      }\n    }\n\n    let word = '';\n    let words = new Set();\n\n    //Go to every node in the grid\n    for (let row = 0; row < grid.length; row++) {\n      for (let col = 0; col < grid[0].length; col++){\n        //Solve for this node as a root\n          findWords(row, col, grid, dictionary, visited, word, root, words);\n      }\n    }\n    return Array.from(words).sort();\n  }else{\n    return([]);\n  }\n}\n\n//exports.findAllSolutions = solver;\nexport default solver;\n"]},"metadata":{},"sourceType":"module"}